use futures::stream::{FuturesUnordered, StreamExt};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use sled::Db;
use std::{sync::Arc, usize};
use tokio::sync::Semaphore;
use uuid::Uuid;
use warp::Filter;

//
// ------ GLOBAL SOZLAMALAR ------
//
const ES_URL: &str =
    "https://search-siemlog-rddlwektckldlou57enditbsqa.eu-north-1.es.amazonaws.com/_search";
const CALLBACK_URL: &str = "http://113.60.91.11:8000/api/v1/elastic/post-json/"; // <— statik callback

const ES_USER: &str = "sardor";
const ES_PASS: &str = "Aws0000$";

//
// ------ MA'LUMOT TUZILMALARI ------
//
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Rule {
    id: String,
    query: serde_json::Value,
}

#[derive(Debug, Clone, Deserialize)]
struct NewRule {
    query: serde_json::Value,
}

type SharedDb = Arc<Db>;

//
// ------ ASOSIY FUNKSIYA ------
//
#[tokio::main]
async fn main() {
    let db = Arc::new(sled::open("rules_db").expect("[x] DB ochilmadi"));
    let db_filter = warp::any().map({
        let db = db.clone();
        move || db.clone()
    });

    // --- REST endpointlar ---
    let add_rule = warp::path("add-rule")
        .and(warp::post())
        .and(warp::body::json())
        .and(db_filter.clone())
        .and_then(add_rule_handler);

    let get_rules = warp::path("rules")
        .and(warp::get())
        .and(db_filter.clone())
        .and_then(get_rules_handler);

    let routes = add_rule.or(get_rules);

    println!("[+] Server http://localhost:3030 da ishga tushdi");

    // --- Worker task (har 1 soniyada) ---
    let db_clone = db.clone();
    let semaphore = Arc::new(Semaphore::new(100)); // 100 ta parallel task limit
    tokio::spawn(async move {
        let client = Client::builder().pool_max_idle_per_host(100).build().unwrap();

        loop {
            let mut tasks = FuturesUnordered::new();

            for result in db_clone.iter().values() {
                let permit = semaphore.clone().acquire_owned().await.unwrap();
                let client = client.clone();

                if let Ok(bytes) = result {
                    if let Ok(rule) = serde_json::from_slice::<Rule>(&bytes) {
                        let rule_clone = rule.clone();

                        // Parallel task yaratamiz
                        tasks.push(tokio::spawn(async move {
                            match client
                                .post(ES_URL)
                                .basic_auth(ES_USER, Some(ES_PASS))
                                .json(&rule_clone.query)
                                .send()
                                .await
                            {
                                Ok(resp) => {
                                    let status = resp.status();
                                    println!(
                                        "[!] recived: [{}] rule_id={} status={}",
                                        chrono::Utc::now(),
                                        rule_clone.id,
                                        status
                                    );

                                    if status.is_success() {
                                        if let Ok(json) = resp.json::<serde_json::Value>().await {
                                            let hits = json["hits"]["total"]["value"]
                                                .as_i64()
                                                .unwrap_or(0);

                                            if hits > 0 {
                                                match client
                                                    .post(CALLBACK_URL)
                                                    .json(&serde_json::json!({
                                                        "data": &json["hits"]["hits"]
                                                    }))
                                                    .send()
                                                    .await
                                                {
                                                    Ok(cb_resp) => println!(
                                                        "[!] sent: [{}] callback rule_id={} status={}",
                                                        chrono::Utc::now(),
                                                        rule_clone.id,
                                                        cb_resp.status()
                                                    ),
                                                    Err(e) => eprintln!(
                                                        "[-]  callback error rule_id={}: {}",
                                                        rule_clone.id, e
                                                    ),
                                                }
                                            }
                                        }
                                    } else {
                                        eprintln!(
                                            "[x] ES query failed rule_id={} status={}",
                                            rule_clone.id, status
                                        );
                                    }
                                }
                                Err(e) => eprintln!("[x] ES error rule_id={}: {}", rule_clone.id, e),
                            }
                            drop(permit); // permitni bo‘shatish
                        }));
                    }
                }
            }

            // Hammasi tugashini kutamiz
            while let Some(_res) = tasks.next().await {}

            tokio::time::sleep(std::time::Duration::from_secs(60)).await;
        }
    });

    // --- HTTP server ---
    warp::serve(routes).run(([0, 0, 0, 0], 3030)).await;
}

//
// ------ HANDLERLAR ------
//
async fn add_rule_handler(
    new_rule: NewRule,
    db: SharedDb,
) -> Result<impl warp::Reply, warp::Rejection> {
    let rule = Rule {
        id: Uuid::new_v4().to_string(),
        query: new_rule.query,
    };

    db.insert(&rule.id, serde_json::to_vec(&rule).unwrap())
        .expect("[-] DB insert error");

    println!("[+] Qoida qo‘shildi: {}", rule.id);
    Ok(warp::reply::json(&rule))
}

async fn get_rules_handler(db: SharedDb) -> Result<impl warp::Reply, warp::Rejection> {
    let rules: Vec<Rule> = db
        .iter()
        .values()
        .filter_map(Result::ok)
        .filter_map(|v| serde_json::from_slice::<Rule>(&v).ok())
        .collect();

    Ok(warp::reply::json(&rules))
}



// ulimit -n 4096